# 第三章 摘下面具

指令指针寄存器(instruction pointer),它包含下一条即将从内存中取出并执行的指令的地址.每当一条指令执行完毕后,这个指令指针都被更新为只想内存中的下一条指令.

`保护模式?(在第四章)`

存储器:内存+CPU寄存器(记忆之王)

___
# 第四章 位置,位置,位置

## 内存模式

### 实模式平面模型(real mode flat model)

最老式的也是现在最古老的内存模式.

### 实模式段模型(real mode segmented model)

最冷人讨厌的东西.

### 保护模式平面模型(protected mode flat model)

现在很多操作系统背后的内存模型.

`CPU的位数`:它的通用寄存器应该包含多少位

`程序段前缀(Program Segment Prefix, PSP)`: 内存前256个字节(CP/M-80),里面包含着各种各样的零碎消息和一个用于程序磁盘输入输出的通用内存缓冲区.可执行代码本身一开始并不运行,知道系统对0100H进行寻址.

### 4.1.4 16位眼罩

在实模式段模型里,X86 CPU 可以"看到" 1MB的内存.也就是说CPU芯片能够将自己设置为只能使用32个地址引脚中的20个.

虽然这些 CPU 可以看到1MB 字节内存,但是它们被限制为只能使用16为"眼罩"来看那1MB字节.

> 我的猜测:要想看到这整整1MB的内存,就需要 段地址+"能看到的内存地址" 如此寻址,就能看到了.

## 4.2 段的本质

|名称|字节|
|---|---|
|字节 |01H|
|字 |  02H|
|双字| 04H|
|四字| 08H|
|十字节| 0AH|
|段落 | 10H|
|页  | 100H|
|段 |  10000H|

段开始的那个段落便捷的编号叫做该段的段地址.
两个相邻的段地址之间并不是紧挨着,而是相距16个字节.
段本身是什么?
    它最大可达64K 字节,但不一定非要那么大.一个段可能只有一个字节长,或者256个字节长,或者21378个字节长,或这任意小于64K的字节长.

### 4.2.1 一个界限,而非一个位置(段的本质)

在实模式下,段内的任何内容都不受保护,而且段并没有被预留出来供某些特定的寄存器或访问方式使用.
段也可以重叠.
段并不真的存在.(再回到CPU佩戴的64KB"眼罩")
段是内存中安装CPU的64KB眼罩的位置,通过这个眼罩查看内存,能够看到从段地址开始,一直到眼罩阻止你的沿途所有字节,一共64KB.

### 4.2.2 用两个16位寄存器 构成20位地址

段地址:偏移地址 构成20位地址,段地址描述段的其实位置(段落),在1MB的内存里,正好也是64K

> x86编程公约规定,当两个数字之间用冒号隔开,用于指定一个地址时,不用再为这两个十六进制数的结尾加上字母H.
> 以段地址:偏移地址的形式书写的地址被假定为以十六进制表示.

## 4.3 16位和32位寄存器

段寄存器:CS,DS,SS,ES,FS,GS,FS `大小仍为16位?`

>所有段寄存器大小都是16位,无论CPU什么型号,甚至对32为CPU也是,
>*`那64为CPU是吗?`*

* CS(code segment)代码段.  包含当前执行指令的代码段你的段地址.
* DS(data segment)数据段.  变量和其他数据存放在数据段的某些偏移位置.也许会有很多歌数据段,但是CPU一次只能使用一个,这是通过将该段的段地址放入DS来实现的.
* SS(stack segment)堆栈段.  CPU用来暂时存放数据和地址的寄存器.
* ES(extra segment)附加段寄存器. 是一个可用于制定内存中某一位置的备用段.
* FS和GS是ES的克隆. 他们都是额外的段.(所以很随意的E,F,G命名))

### 4.3.1 通用寄存器

在32为CPU中,通用寄存器分为三个类:16位通用寄存器, 32位扩展通用寄存器, 8位半寄存器.
这三类并不代表三个完全不同的寄存器组,16位和8位寄存器实际上是32位寄存器内部的一块区域的名字.

> 书上的比喻:在家里添加一个房间,并不能让你拥有两套房子,只是有了一个更大的房子.

8个16位通用寄存器: AX, BX, CX, DX, BP, SI, DI, SP.(他们的大小都为16位)

后来1986年,Intel将X86体系结构扩展位32位,它把八个通用寄存器的大小增加了一倍,并且通过原有的名字在前面加上前缀`E`来对它们进行新的命名,
`EAC`, `EBX`, `ECX`, `EDX`, `EBP`, `ESI`, `EDI`, `ESP`

> 那么问题来了,这些寄存器是在原有的基础上变大了一些的寄存器,还是新的寄存器呢?
> 答: 都是.(话说原有的寄存器变大了,不就是新的吗?); 总之,他是兼容16位寄存器的.
> 换句话说,新的32位寄存器的 *低16位* 就是就得16位寄存器.高16位,没有名字,别瞎想了.

### 4.3.2 半寄存器

其他的4个通用寄存器(EAX, EBX, ECX, EDX)也存在其16位的名字.
但是还有个额外的技巧:**低16位**本身再次被分成了两个 **8位** 的半寄存器.
寄存器AX对应的两个半寄存器为`AH`和`AL` (High代表高位,Low代表低位))
BX的两个半寄存器为`BH`和`BL`,以此类推.

### 4.3.3 指令指针寄存器(Instruction Pointer)

>IP 或 32位保护模式下, EIP

它只可以做一件事情:包含当前代码段中的下一条即将执行的机器指令的偏移地址.
