# 第三章 摘下面具

指令指针寄存器(instruction pointer),它包含下一条即将从内存中取出并执行的指令的地址.每当一条指令执行完毕后,这个指令指针都被更新为只想内存中的下一条指令.

`保护模式?(在第四章)`

存储器:内存+CPU寄存器(记忆之王)

___
# 第四章 位置,位置,位置

## 内存模式

### 实模式平面模型(real mode flat model)

最老式的也是现在最古老的内存模式.

### 实模式段模型(real mode segmented model)

最冷人讨厌的东西.

### 保护模式平面模型(protected mode flat model)

现在很多操作系统背后的内存模型.

`CPU的位数`:它的通用寄存器应该包含多少位

`程序段前缀(Program Segment Prefix, PSP)`: 内存前256个字节(CP/M-80),里面包含着各种各样的零碎消息和一个用于程序磁盘输入输出的通用内存缓冲区.可执行代码本身一开始并不运行,知道系统对0100H进行寻址.

### 4.1.4 16位眼罩

在实模式段模型里,X86 CPU 可以"看到" 1MB的内存.也就是说CPU芯片能够将自己设置为只能使用32个地址引脚中的20个.

虽然这些 CPU 可以看到1MB 字节内存,但是它们被限制为只能使用16为"眼罩"来看那1MB字节.

> 我的猜测:要想看到这整整1MB的内存,就需要 段地址+"能看到的内存地址" 如此寻址,就能看到了.

## 4.2 段的本质

|名称|字节|
|---|---|
|字节 |01H|
|字 |  02H|
|双字| 04H|
|四字| 08H|
|十字节| 0AH|
|段落 | 10H|
|页  | 100H|
|段 |  10000H|

段开始的那个段落便捷的编号叫做该段的段地址.
两个相邻的段地址之间并不是紧挨着,而是相距16个字节.
段本身是什么?
    它最大可达64K 字节,但不一定非要那么大.一个段可能只有一个字节长,或者256个字节长,或者21378个字节长,或这任意小于64K的字节长.

### 4.2.1 一个界限,而非一个位置(段的本质)

在实模式下,段内的任何内容都不受保护,而且段并没有被预留出来供某些特定的寄存器或访问方式使用.
段也可以重叠.
段并不真的存在.(再回到CPU佩戴的64KB"眼罩")
段是内存中安装CPU的64KB眼罩的位置,通过这个眼罩查看内存,能够看到从段地址开始,一直到眼罩阻止你的沿途所有字节,一共64KB.

### 4.2.2 用两个16位寄存器 构成20位地址

段地址:偏移地址 构成20位地址,段地址描述段的其实位置(段落),在1MB的内存里,正好也是64K

> x86编程公约规定,当两个数字之间用冒号隔开,用于指定一个地址时,不用再为这两个十六进制数的结尾加上字母H.
> 以段地址:偏移地址的形式书写的地址被假定为以十六进制表示.

